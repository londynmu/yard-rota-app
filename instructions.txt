1. Najpierw przeczytaj plik README.md zanim wykonasz jakiekolwiek zadanie.
2. Nie twórz nowych funkcji ani pomysłów, które nie były opisane lub o które Cię nie poproszono.
3. Realizuj tylko konkretne polecenia, bez domyślania się ani dopisywania własnych inicjatyw.
4. Po zakończeniu każdego zadania zaktualizuj plik README.md o dokładny opis:
   - Co zostało zrobione?
   - Jakie pliki lub fragmenty kodu zostały zmienione?
   - Czy są dalsze kroki do wykonania.
5. Pracujesz nad aplikacją mobilną (układanie grafików pracowniczych):
   - Interfejs MOBILE-FRIENDLY.
   - Prostota, szybkość i czytelność.
6. Dostarczaj gotowe, praktyczne rozwiązania: kod funkcji, fragmenty HTML, CSS, JS, React, backend jeśli potrzebne.
7. Proponuj tylko najlepsze i najprostsze rozwiązanie.
8. Jeśli coś wymaga decyzji – zatrzymaj się i zapytaj użytkownika przed kontynuacją.
9. Zawsze staraj sie aby front end aplikacji dzialal  z backend aplikacji 
10. Strona jest po angielsku . my tyylko rozmawiamy po polsku . strona w jezyku ANGIELSKIM

Styl odpowiedzi:
- Krótko, konkretnie, profesjonalnie.
- Czytelne i gotowe do użycia fragmenty kodu.
- Zawsze na końcu zapisuj zmiany w README.md. 
## Persistent UI State

To improve usability and avoid resetting the user interface unnecessarily when navigating:

- Store current tab/section state (e.g. in Admin Settings) using `localStorage` or `sessionStorage`
- On component mount, read last used section and restore it
- Do not force-refresh subviews unless required
- Avoid redirecting user to default tab/view unless no state is found

Example:
- If user was in `Settings → Preferences`, and returns, keep them there
- If user last viewed the `Locations` section, restore that tab

Implementation suggestion:
```js
// Save on change
useEffect(() => {
  localStorage.setItem('adminSettingsTab', activeTab);
}, [activeTab]);

// Load on mount
useEffect(() => {
  const savedTab = localStorage.getItem('adminSettingsTab');
  if (savedTab) setActiveTab(savedTab);
}, []);

. jezeli robisz jakis modal to upewnij sie ze literki sa widoczne  na przyklad czarne na bialym tle . 
. jezeli tworzysz okienko do ustawiania czasu to rob tak aby bylo mozliwe wstawianie czasu co 15 minut (nie 900 sekund) tylko w formacie 00 15 30 45 
. na widoku mobilnym wyswietlanie powinno byc z minimalnymi marginesami , I jezeli jest kontener jakis to niech zajmuje prawie  cala szerokosc ekranu dla lepszej obslugi i widocznosci zawartych w nim elementow

## Powiadomienia (Toast Notifications)

Wszystkie powiadomienia w aplikacji powinny:
- Pojawiać się na środku ekranu z efektem rozmycia tła (backdrop-blur)
- Mieć animacje wejścia/wyjścia (fade-in + scale)
- Być dobrze widoczne z kontrastowymi kolorami
- Automatycznie znikać po 2 sekundach
- Używać ikon odpowiednich do typu powiadomienia (success, error, info)

Implementacja wzorcowa:
```jsx
// ToastNotification.jsx
import React, { useEffect, useState } from 'react';
import ReactDOM from 'react-dom';

export default function ToastNotification({ message, type = 'info', onClose, autoCloseTime = 2000 }) {
  const [visible, setVisible] = useState(false);
  
  useEffect(() => {
    // Show with a tiny delay for animation
    const showTimer = setTimeout(() => {
      setVisible(true);
    }, 10);
    
    // Auto-close after specified time
    const closeTimer = setTimeout(() => {
      setVisible(false);
      setTimeout(onClose, 300); // Wait for fade out
    }, autoCloseTime);
    
    return () => {
      clearTimeout(showTimer);
      clearTimeout(closeTimer);
    };
  }, [onClose, autoCloseTime]);
  
  return ReactDOM.createPortal(
    <div className="fixed inset-0 flex items-center justify-center z-50 pointer-events-none">
      {/* Semi-transparent backdrop with blur */}
      <div className={`absolute inset-0 backdrop-blur-sm bg-black/10 transition-opacity duration-300 
        ${visible ? 'opacity-100' : 'opacity-0'}`} />
        
      {/* Toast container */}
      <div className={`
        px-5 py-4 rounded-lg shadow-2xl max-w-md text-center font-medium 
        transition-all duration-300 transform
        ${visible ? 'opacity-100 scale-100' : 'opacity-0 scale-95'}
        ${type === 'success' ? 'bg-green-600/90 text-white border border-green-500' : 
          type === 'error' ? 'bg-red-600/90 text-white border border-red-500' :
          'bg-blue-600/90 text-white border border-blue-500'}
      `}>
        <div className="flex items-center justify-center space-x-3">
          {/* Icon based on type */}
          <span className="text-base">{message}</span>
        </div>
      </div>
    </div>,
    document.body
  );
}
```

Użycie:
```jsx
const [toast, setToast] = useState(null);

// Pokaż powiadomienie
const showToast = (message, type = 'info') => {
  setToast({ message, type });
};

// Wyczyść powiadomienie
const clearToast = () => {
  setToast(null);
};

// W komponencie
{toast && (
  <ToastNotification 
    message={toast.message} 
    type={toast.type} 
    onClose={clearToast} 
  />
)}
```

## Komponenty Liczbowe (Capacity Selector)

Komponenty do wyboru liczb (np. pojemność, ilość) powinny:
- Być zawarte w jednym prostokątnym elemencie z zaokrąglonymi rogami
- Zajmować pełną szerokość dostępnego kontenera
- Mieć trzy sekcje o równej szerokości: minus, wyświetlacz wartości, plus
- Mieć wyraźny kontrast między tłem przycisków a tłem wyświetlanej wartości
- Być wystarczająco duże, aby łatwo je obsługiwać na urządzeniach mobilnych

Przykładowa implementacja:
```jsx
<div className="flex items-center bg-gray-800 rounded-lg border border-white/20 overflow-hidden w-full">
  <button
    type="button"
    onClick={() => {
      if (value > minValue) {
        onChange(value - 1);
      }
    }}
    className="px-4 py-3 text-white hover:bg-gray-700 flex-1 flex justify-center"
  >
    <svg /* Ikona minusa */ />
  </button>
  <div className="py-3 bg-gray-900 text-white text-center flex-1 font-medium text-lg">
    {value}
  </div>
  <button
    type="button"
    onClick={() => onChange(value + 1)}
    className="px-4 py-3 text-white hover:bg-gray-700 flex-1 flex justify-center"
  >
    <svg /* Ikona plusa */ />
  </button>
</div>
```

## Selektory Czasu (TimePicker)

Selektory czasu powinny:
- Automatycznie przewijać się do aktualnie wybranej wartości po otwarciu (bez ręcznego przewijania)
- Używać formatu minut 00, 15, 30, 45 dla 15-minutowych przyrostów
- Mieć czytelne, kontrastowe kolory dla wybranych wartości
- Wyraźnie oznaczać aktualnie wybraną godzinę/minutę

Implementacja automatycznego przewijania do aktualnej wartości:
```jsx
// Refs do kontenerów i wybranych elementów
const hoursContainerRef = useRef(null);
const selectedHourRef = useRef(null);

// Efekt dla automatycznego przewijania po otwarciu
useEffect(() => {
  const timer = setTimeout(() => {
    if (selectedHourRef.current && hoursContainerRef.current) {
      selectedHourRef.current.scrollIntoView({
        behavior: 'auto',
        block: 'center'
      });
    }
  }, 50);
  
  return () => clearTimeout(timer);
}, []);

// W komponencie
<div ref={hoursContainerRef} className="overflow-y-auto">
  {hours.map(hour => (
    <button
      key={hour}
      ref={selectedHour === hour ? selectedHourRef : null}
      className={selectedHour === hour ? 'bg-blue-600' : ''}
      onClick={() => setSelectedHour(hour)}
    >
      {hour}
    </button>
  ))}
</div>
```
